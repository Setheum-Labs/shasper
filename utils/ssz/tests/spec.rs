use ssz::{Encode, Decode, MaxVec, Compact};
use generic_array::GenericArray;
use core::fmt::Debug;
use typenum::*;

fn t<T: Debug + Encode + Decode + PartialEq>(value: T, expected: &[u8]) {
	let encoded = value.encode();
	assert_eq!(&encoded[..], expected);
	let decoded = T::decode(&mut &encoded[..]).unwrap();
	assert_eq!(value, decoded);
}

#[test]
fn spec() {
	t(false, &[0x00]); // boolean F
	t(true, &[0x01]); // boolean T
	t(0u8, &[0x00]); // uint8 00
	t(1u8, &[0x01]); // uint8 01
	t(0xabu8, &[0xab]); // uint8 ab
	t(0x0000u16, &[0x00, 0x00]); // uint16 0000
	t(0xabcdu16, &[0xcd, 0xab]); // uint16 abcd
	t(0x00000000u32, &[0x00, 0x00, 0x00, 0x00]); // uint32 00000000
	t(0x01234567u32, &[0x67, 0x45, 0x23, 0x01]); // uint32 01234567

	// uint64 0000000000000000
	t(0x0000000000000000u64, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
	// uint64 0123456789abcdef
	t(0x0123456789abcdefu64, &[0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01]);

	// bitvector TTFTFTFF
	t(Compact(GenericArray::<bool, U8>::from([true, true, false, true, false, true, false, false])), &[0x2b]);
	// bitvector FTFT
	t(Compact(GenericArray::<bool, U4>::from([false, true, false, true])), &[0x0a]);
	// bitvector FTF
	t(Compact(GenericArray::<bool, U3>::from([false, true, false])), &[0x02]);
	// bitvector TFTFFFTTFT
	t(Compact(GenericArray::<bool, U10>::from([true, false, true, false, false, false, true, true, false, true])), &[0xc5, 0x02]);
	// bitvector TFTFFFTTFTFFFFTT
	t(Compact(GenericArray::<bool, U16>::from([true, false, true, false, false, false, true, true, false, true,
								 false, false, false, false, true, true])),
	  &[0xc5, 0xc2]);
	// long bitvector
	{
		let mut v = GenericArray::<bool, U512>::default();
		for i in 0..512 {
			v[i] = true;
		}
		t(Compact(v),
		  &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
	}

	// long bitlist
	{
		let mut v = MaxVec::<bool, U513>::default();
		for _ in 0..512 {
			v.push(true);
		}
		t(Compact(v),
		  &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x01]);
	}

	// longer bitlist
	{
		let mut v = MaxVec::<bool, U513>::default();
		for _ in 0..513 {
			v.push(true);
		}
		t(Compact(v),
		  &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x03]);
	}
}
